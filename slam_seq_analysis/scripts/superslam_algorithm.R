mark.excluded.ks <- function (p.error, cutoff.mult, data) 
{
                                        #contrib.error is the contribution of events from p.error multiplied by the cutoff threshold
                                        #exclude is TRUE if frequency of events from p.error > 1/cutoff x observed a_kn
    data$contrib.error = cutoff.mult * dbinom(x = data$k, size = data$N, 
        prob = p.error) * data$sum.akn
    data$exclude = ifelse(data$akn==0,FALSE,data$akn < data$contrib.error)
    data
}

estimate.excluded.counts <- function(k,N,prob,sum.akn){
                                        # estimates counts for excluded events by multiplying the sum of all
                                        #non-excluded events by the binomial coeffecients generated by p.conv
    dbinom(x=k,size=N,prob=prob)/sum(dbinom(x=(max(k)+1):N,size=N,prob=prob))*sum.akn
}

replace.excluded.counts <- function(p.conv,data){
                                        # replaces excluded counts in the data by their estimates
    group_by(data,N) %>%
        mutate(akn=ifelse(exclude,estimate.excluded.counts(k[exclude],N[1],p.conv,sum(akn[!exclude])),akn))
}

ml.estimate.pconv <- function(data){
                                        # computes the ML estimate for p.conv
    k=data$k
    N=data$N
    akn=data$akn
    p=sum(as.numeric(k*akn))/sum(as.numeric(N*akn))
}    


em.algorithm.pconv <- function(prob.error,cutoff.mult,data){
                                        # Implements the EM algorithm for estimating p.conv
    d0=data
    ll=0
    rr=1
    while (abs(ll-rr)>1e-8){
        pi=(ll+rr)/2
        d0=replace.excluded.counts(pi,mark.excluded.ks(prob.error,cutoff.mult,d0))
        if (sum(d0$exclude)==nrow(d0)){
            pi=NA
            break
        }
        pi.plus.one=ml.estimate.pconv(d0)
        if (pi.plus.one < pi){
            rr=pi
        }else{
            ll=pi
        }
    }
    excl <- mark.excluded.ks(prob.error,cutoff.mult,d0)
    data_frame(pr=pi,fract.included=sum(excl$akn[!excl$exclude])/sum(data$akn),no.included=sum(excl$akn[!excl$exclude]))
}


compute.error.rate <- function(data.in){
    colnames(data.in) <- c("X1","X2","X3")
    data.in %>%
        mutate(all.T=X1*X3,all.T2C=X2*X3) %>%
        summarise(all.T=sum(as.numeric(all.T)),all.T2C=sum(as.numeric(all.T2C))) %>%
        mutate(p.error=all.T2C/all.T) ->
        error.estimates
    error.estimates$p.error
}



compute.conversion.rate <- function(data.in,p.error,threshold.excluded.events){
                                        # data for the em algorithm is supplied in the form
                                        # N (number of Ts in read), k (number of T2Cs in read),
                                        # akn (number of reads with N Ts and k T2Cs)
    colnames(data.in) <- c("X1","X2","X3")
    ss=sum(data.in$X3[data.in$X2>0])
    if (ss>1000){
    data.in %>%
        select(N=X1,k=X2,akn=X3) %>%
        group_by(N) %>%
        mutate(sum.akn=sum(akn)) %>%
        ungroup %>%
        em.algorithm.pconv(p.error,threshold.excluded.events,.) ->
        out.frame
    }else{
        out.frame <- data_frame(pr=NA, fract.included=NA, no.included=NA)
    }
    out.frame
}

